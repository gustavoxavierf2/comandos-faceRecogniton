# -*- coding: utf-8 -*-
"""face_recognition.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nWo0wP__0pjm7JaA9dXg1-Nog3ouhYGE
"""

#!pip install face_recognition

import cv2
import numpy as np
import face_recognition as fc
import matplotlib.pyplot as plt

"""abre a imagem e atribui a variavel img1, e converte bgr para rgb

"""

img1 = cv2.cvtColor(cv2.imread('img1.png'), cv2.COLOR_BGR2RGB)

img1.shape

def visu_img(img):
    plt.axis('off')
    plt.imshow(img)
    plt.show()

"""grafico gerado, convertendo o array em grafico, revelanndo a foto"""

visu_img(img1)

"""#mode='RGB' ja e o padrao deste modo de carregar a imagem
mode='L' preto e branco, somente 2 dimençoes
"""

img2 = fc.load_image_file('img2.png')

"""[0] representa q quero o primeiro rosto encontrado"""

localiza_rosto = fc.face_locations(img1)[0] #top, right, bottom, left

"""atribui a cada variavel a posiçao no array"""

top1, right1, bottom1, left1 = localiza_rosto

"""percorre o arry neste sentido top ate bottom e left ate right"""

face1 = img1[top1:bottom1,left1:right1]

face1

visu_img(face1)

"""number_of_times_to_upsample=1 ao aumentar o numero por padrao 1, percorre a imagem novamente a procura de rostos cada vez menores

'hog' metodo mais lleve n utiliza deep learning, utiiza PDI
'cnn' usa deep learning, mais preciso
"""

fc.face_locations(img1, number_of_times_to_upsample=2, model='cnn')[0] #top, right, bottom, left

img3 = cv2.cvtColor(cv2.imread('img1.webp'), cv2.COLOR_BGR2RGB)

img1.shape

"""este metodo verifica um array com varia imagens, so roda em pcs que tenham GPU

as imagens devem ter todas as mesmas dimençoes
"""

fc.batch_face_locations(images=[img1,img1], number_of_times_to_upsample=1, batch_size=128)

"""array com os 128 pontos da face

parametros: se passarmos a imagem direto ele localiza internamente o rosto e os pontos da face

se passamos a imagem com a llocailzaçao do rosto junto(metodo face_location) ele reailza o processo mais rapidamente

num_jitters=1 padrao, quanto maior mais preciso a sera esta represenaçao de 128 caracteristicas, mais custoso
"""

fc.face_encodings(img1, num_jitters=1)

atributos_rosto1=fc.face_encodings(img1)[0]
atributos_rosto2=fc.face_encodings(img3)[0]

"""o primeiro parametro e um vetor por isso os [], o segundo e oq quero comparar

tolerancia caso o valor do metodo(face_distance) for maior q a setada ira retornar falso, o.6 padrao
"""

fc.compare_faces([atributos_rosto1], atributos_rosto2, tolerance=0.6)

"""distancia de quanta as imagens sao diferentes uma da outra"""

fc.face_distance([atributos_rosto1], atributos_rosto2)

"""determina os pontos do rosto, ex:olho direiro, esquerdo, boca, nariz"""

bolinhas = fc.face_landmarks(img1)[0]

"""para cada mark dentro de bolinhas.keys

para cada pontos em bolinhas[mark]

faça um circulo na imagem
"""

for mark in bolinhas.keys():
  for pontos in bolinhas[mark]:
      cv2.circle(img1, pontos, 3, (0,255,0), -1)

"""model='small' deixa os landmarks menores"""

fc.face_landmarks(img1, model='small')[0]

